<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>360° WebXR Viewer</title>
  <script src="https://cdn.jsdelivr.net/npm/aframe@1.7.0/dist/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-extras@6.1.1/dist/aframe-extras.min.js"></script>
  <script src="/stereo-sbs.js"></script>
  <style>
    body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; }
    #file-input { position: absolute; top: 10px; left: 10px; z-index: 1000; }
    #play-pause-btn {
      position: absolute; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000; padding: 10px 20px;
      font-size: 16px; display: none;
    }
    #seek-bar {
      position: absolute; left: 50%; bottom: 5%;
      transform: translateX(-50%);
      z-index: 1000; width: 50%; display: none;
    }
    a-scene {
      width: 100%; height: 100%;
      position: absolute; top: 0; left: 0;
    }
  </style>
</head>
<body>
  <input type="file" id="file-input" accept="image/*,video/*" />
  <button id="play-pause-btn">Play</button>
  <input type="range" id="seek-bar" min="0" max="100" step="0.1" value="0" />
  <pre id="folder-info" style="position:absolute; right:10px; top:10px; z-index:1000; background:rgba(0,0,0,0.5); color:#fff; padding:8px; margin:0; max-width:40vw; max-height:40vh; overflow:auto; font-size:12px; display:none"></pre>

  <a-scene background="color:#88c" embedded vr-mode-ui="enabled: true" isMobile="false">
    <a-assets>
      <img id="imageAsset" crossorigin="anonymous" />
      <video id="videoAsset" crossorigin="anonymous" webkit-playsinline playsinline  loop="false"></video>
    </a-assets>
    <a-entity id="camrig" rotation="0 180 0">
      <a-entity camera look-controls position="0 1.6 0"></a-entity>
      <a-entity id="lhand"
                hand-tracking-controls="hand: left;modelColor:#222;modelStyle:none"
                pinch-handler>
      </a-entity>
      <a-entity id="rhand"
                hand-tracking-controls="hand: right;modelColor:#222;modelStyle:none"
                pinch-handler>
      </a-entity>
      <a-entity id="left-controller" hand-controls="hand: left" controller-listener></a-entity>
      <a-entity id="right-controller" hand-controls="hand: right" controller-listener></a-entity>
    </a-entity>

    <a-sky id="sky" src="#imageAsset" visible="false" segments-height=50 segments-width=100></a-sky>
    <a-videosphere id="video-sphere" src="#videoAsset" loop="true" visible="false"></a-videosphere>
    <a-entity id="stereo-sphere"
              geometry="primitive: sphere; radius: 20; segmentsWidth: 100; segmentsHeight: 50"
              position="0 0 0"
              visible="false"
              stereo-sbs="monoEye: left"></a-entity>
  </a-scene>

  <script>
    // UI elements
    const fileInput = document.getElementById('file-input');
    const playPauseBtn = document.getElementById('play-pause-btn');
    const seekBar = document.getElementById('seek-bar');
    // A-Frame elements
    const sceneEl = document.querySelector('a-scene');
    const skyEl = document.getElementById('sky');
    const videoSphere = document.getElementById('video-sphere');
    const stereoSphere = document.getElementById('stereo-sphere');
    const imageAsset = document.getElementById('imageAsset');
    const videoAsset = document.getElementById('videoAsset');
    let currentDirInfo = null; // holds info from folder (.info.json)

    // Toggle play/pause
    function togglePlayPause() {
      if (!videoAsset.src) return;
      if (videoAsset.paused) {
        videoAsset.play();
        playPauseBtn.textContent = 'Pause';
      } else {
        videoAsset.pause();
        playPauseBtn.textContent = 'Play';
      }
    }

    // Load image or video
    // filename: original file name (used to detect _sbs for VR180)
    function loadMedia(src, isVideo, filename) {
      fileInput.style.display = 'none';
      const nameForDetect = filename || src || '';
      const isVR180 = (currentDirInfo && currentDirInfo.type === 'vr180') || /_sbs\./i.test(nameForDetect);

      if (isVideo) {
        imageAsset.removeAttribute('src');
        skyEl.setAttribute('visible', 'false');
        videoAsset.setAttribute('src', src);
        if (isVR180) {
          // Use stereo-sbs component for VR180 video
          // halfTurn true to bring the VR180 hemisphere to the front, matching still-image behavior
          stereoSphere.setAttribute('stereo-sbs', 'src: #videoAsset; monoEye: left; halfTurn: true');
          stereoSphere.setAttribute('visible', 'true');
          videoSphere.setAttribute('visible', 'false');
        } else {
          videoSphere.setAttribute('visible', 'true');
          stereoSphere.setAttribute('visible', 'false');
        }
        playPauseBtn.style.display = 'block';
        seekBar.style.display = 'block';
        videoAsset.addEventListener('loadedmetadata', () => { seekBar.max = videoAsset.duration; });
        videoAsset.addEventListener('timeupdate', () => { seekBar.value = videoAsset.currentTime; });
        seekBar.addEventListener('input', () => { videoAsset.currentTime = seekBar.value; });
        playPauseBtn.addEventListener('click', togglePlayPause);
        sceneEl.addEventListener('triggerdown', togglePlayPause);
      } else {
        videoAsset.pause();
        videoAsset.removeAttribute('src');
        videoSphere.setAttribute('visible', 'false');
        if (isVR180) {
          // Use stereo-sbs for VR180 image
          stereoSphere.setAttribute('stereo-sbs', 'src: #imageAsset; monoEye: left; halfTurn: true');
          stereoSphere.setAttribute('visible', 'true');
        } else {
          stereoSphere.setAttribute('visible', 'false');
        }
//       skyEl.setAttribute('visible', 'false');
        imageAsset.setAttribute('src', src);
        imageAsset.addEventListener('load', () => {
          if (!isVR180) {
            // 非VR180: a-skyに反映（カバー調整）
            skyEl.setAttribute('src', '#imageAsset');

            const replaceSkyTexture = () => {
              const mesh = skyEl.getObject3D('mesh');
              if (!(mesh && mesh.material)) return false;
              const THREE = AFRAME.THREE;
              const newTex = new THREE.Texture(imageAsset);
              if (THREE.SRGBColorSpace) {
                newTex.colorSpace = THREE.SRGBColorSpace;
              } else if (THREE.sRGBEncoding) {
                newTex.encoding = THREE.sRGBEncoding;
              }
              newTex.minFilter = THREE.LinearFilter;
              newTex.magFilter = THREE.LinearFilter;
              newTex.generateMipmaps = false;
              newTex.flipY = true;
              newTex.wrapS = THREE.ClampToEdgeWrapping;
              newTex.wrapT = THREE.ClampToEdgeWrapping;

              const iw = imageAsset.naturalWidth || (newTex.image && newTex.image.width) || 0;
              const ih = imageAsset.naturalHeight || (newTex.image && newTex.image.height) || 1;
              const A = iw / ih;
              const D = 2; // 2:1
              let rx = 1, ry = 1, ox = 0, oy = 0;
              if (A > D) { rx = D / A; ox = (1 - rx) / 2; }
              else if (A < D) { ry = A / D; oy = (1 - ry) / 2; }
              newTex.repeat.set(rx, ry);
              newTex.offset.set(ox, oy);
              newTex.needsUpdate = true;

              if (mesh.material.map && mesh.material.map.dispose) {
                try { mesh.material.map.dispose(); } catch (e) {}
              }
              mesh.material.map = newTex;
              mesh.material.needsUpdate = true;
              return true;
            };

            if (!replaceSkyTexture()) {
              const onReady = () => { replaceSkyTexture(); };
              skyEl.addEventListener('materialtextureloaded', onReady, { once: true });
            }

            skyEl.setAttribute('visible', 'true');
          } else {
            // VR180画像: stereo-sphereを使用
            skyEl.setAttribute('visible', 'false');
          }
        }, { once: true });
        playPauseBtn.style.display = 'none';
        seekBar.style.display = 'none';
      }
    }

    // File input handler
    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      currentDirInfo = null;
      // Use original file name for _sbs detection
      loadMedia(URL.createObjectURL(file), file.type.startsWith('video/'), file.name);
    });

    // URL query handler and conditional WS connect
    window.addEventListener('load', () => {
      const raw = window.location.search;
      // Support both legacy `?path/to/file.ext` and key-value like `?path/to/file.jpg&type=vr180`.
      // Also accept explicit keys: src=, file=, path=
      const search = (raw && raw.length > 1) ? raw.substring(1) : '';

      let srcPath = '';
      let info = {};

      if (search) {
        if (search.includes('=')) {
          // Parse key-value pairs and also allow a leading bare path as a key with empty value
          const usp = new URLSearchParams(search);
          // Prefer explicit keys if present
          srcPath = usp.get('src') || usp.get('file') || usp.get('path') || '';
          if (!srcPath) {
            // Look for first entry with empty value (e.g., ?data/a.jpg&type=vr180)
            for (const [k, v] of usp.entries()) {
              if (v === '' && k) { srcPath = k; break; }
            }
          }
          // Build info object from remaining params
          for (const [k, v] of usp.entries()) {
            if (k === 'src' || k === 'file' || k === 'path') continue;
            // Skip the synthetic bare-path param (empty value)
            if (v === '' && k === srcPath) continue;
            info[k] = v;
          }
        } else {
          // Legacy: whole query is the path
          srcPath = search;
        }
      }

      if (srcPath) {
        currentDirInfo = Object.keys(info).length ? info : null;
        const fname = srcPath.split('/').pop();
        loadMedia(srcPath, /\.(mp4|webm|ogg)$/i.test(srcPath), fname);
        // Optional: show info if provided
        const infoEl = document.getElementById('folder-info');
        if (infoEl && currentDirInfo) {
          infoEl.style.display = 'block';
          try { infoEl.textContent = JSON.stringify(currentDirInfo, null, 2); } catch (_) {}
        }
        // When a file is specified via query, do not connect to WS
      } else {
        // No file specified via query; connect to WS server
        if (typeof connect === 'function') connect();
      }
    });

    // eventsource 
    const baseUrl = 'data/';

    let ws;
    function log(msg) {
      const data = typeof msg === 'string' ? msg : JSON.stringify(msg);
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(data);
      }
    }

    function connect() {
      ws = new WebSocket(`wss://${location.host}`);
      ws.onopen = () => {
        log('接続済み');
      };
      ws.onerror = () => {
        log('接続エラー');
      };
      ws.onmessage = e => {
        let payload;
        try {
          payload = JSON.parse(e.data);
        } catch (_) {
          payload = e.data;
        }

        let files = [];
        let info = null;
        let relPath = '';
        if (Array.isArray(payload)) {
          files = payload;
        } else if (payload && typeof payload === 'object') {
          files = Array.isArray(payload.files) ? payload.files : [];
          info = payload.info || null;
          relPath = payload.path || '';
        }

        // update info overlay
        const infoEl = document.getElementById('folder-info');
        currentDirInfo = info || null;
        if (info) {
          infoEl.textContent = JSON.stringify({ path: relPath, info }, null, 2);
          infoEl.style.display = 'block';
        } else {
          infoEl.textContent = '';
          infoEl.style.display = 'none';
        }

        if (files && files.length > 0) {
          console.log('Selected via WS:', files, info);
          const p = baseUrl + files[0];
          const fname = files[0].split('/').pop();
          loadMedia(p, /\.(mp4|webm|ogg)$/i.test(p), fname);
        }
      };
      ws.onclose = () => {
        log("reconnecting...");
        setTimeout(connect, 1000);
      };
    }

    // A-Frameコンポーネント：ハンドトラッキングpinch操作の統合
    AFRAME.registerComponent('pinch-handler', {
      init: function() {
        this.startX = null;
        this.startY = null;
        this.flicked = false;
        this.sceneEl = this.el.sceneEl;
        this.skyEl = this.sceneEl.querySelector('#sky');
        this.videoSphere = this.sceneEl.querySelector('#video-sphere');
        this.stereoSphere = this.sceneEl.querySelector('#stereo-sphere');
        this.togglePlayPause = function() {
          if (!videoAsset.src) return;
          if (videoAsset.paused) {
            videoAsset.play();
            playPauseBtn.textContent = 'Pause';
          } else {
            videoAsset.pause();
            playPauseBtn.textContent = 'Play';
          }
        };
        this.el.addEventListener('pinchstarted', this.onPinchStart.bind(this));
        this.el.addEventListener('pinchmoved', this.onPinchMove.bind(this));
        this.el.addEventListener('pinchended', this.onPinchEnd.bind(this));
      },
      onPinchStart: function(evt) {
        this.startX = evt.detail.position.x;
        this.startY = evt.detail.position.y;
        this.flicked = false;
      },
      onPinchMove: function(evt) {
        if (this.startX === null || this.startY === null) return;
        const currentX = evt.detail.position.x;
        const currentY = evt.detail.position.y;
        const deltaX = currentX - this.startX;
        const deltaY = currentY - this.startY;
        const horizThreshold = 0.1;
        const vertThreshold = 0.02;
        if (Math.abs(deltaX) > horizThreshold && Math.abs(deltaY) < vertThreshold) {
          const targetEl = this.skyEl.getAttribute('visible') ? this.skyEl : (this.videoSphere.getAttribute('visible') ? this.videoSphere : this.stereoSphere);
          const rotation = targetEl.getAttribute('rotation');
          rotation.y += (deltaX > 0 ? -30 : 30);
          targetEl.setAttribute('rotation', rotation);
          this.flicked = true;
          this.startX = currentX;
          this.startY = currentY;
        }
      },
      onPinchEnd: function() {
        if (this.startX === null) return;
        // Toggle play/pause on tap-like pinch end if not a horizontal flick
        if (!this.flicked && videoAsset && videoAsset.src) {
          this.togglePlayPause();
        }
        this.startX = null;
      }
    });
  AFRAME.registerComponent('controller-listener', {
    init: function() {
      this.prevAxis = [0, 0,0,0];
      this.sceneEl = this.el.sceneEl;
      this.skyEl = this.sceneEl.querySelector('#sky');
      this.videoSphere = this.sceneEl.querySelector('#video-sphere');
      this.stereoSphere = this.sceneEl.querySelector('#stereo-sphere');
      this.el.addEventListener('axismove', this.onAxisMove.bind(this));
      // Support both A-Frame controller events and WebXR generic events
      this.el.addEventListener('triggerdown', this.onTriggerDown.bind(this));
    },
    onAxisMove: function(evt) {
      const axis = evt.detail.axis;
      const currX = axis[2];
      const prevX = this.prevAxis[2];
      const threshold = 0.9;
//      log(prevX + " -> " + currX);
      if (prevX <= threshold && currX > threshold) {
        this.rotateBy(30);
      } else if (prevX >= -threshold && currX < -threshold) {
        this.rotateBy(-30);
      }
      this.prevAxis = [...axis];
    },
    rotateBy: function(deg) {
      const targetEl = this.skyEl.getAttribute('visible') ? this.skyEl : (this.videoSphere.getAttribute('visible') ? this.videoSphere : this.stereoSphere);
      const rotation = targetEl.getAttribute('rotation');
      targetEl.setAttribute('rotation', { x: rotation.x, y: rotation.y + deg, z: rotation.z });
    },
    onTriggerDown: function() {
      log("triggerdown");
      if (!videoAsset.src) return;
      if (videoAsset.paused) {
        videoAsset.play();
        playPauseBtn.textContent = 'Pause';
      } else {
        videoAsset.pause();
        playPauseBtn.textContent = 'Play';
      }
    }
  });
  </script>
</body>
</html>
